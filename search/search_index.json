{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Bulder Bank Blog \u00b6","title":"Home"},{"location":"#welcome-to-the-bulder-bank-blog","text":"","title":"Welcome to the Bulder Bank Blog"},{"location":"android/about/","text":"About our Android Team \u00b6 Alexander Arnesen Android Lead David Olsson Android Developer","title":"About our Android Team"},{"location":"android/about/#about-our-android-team","text":"Alexander Arnesen Android Lead David Olsson Android Developer","title":"About our Android Team"},{"location":"backend/about/","text":"About our Backend Team \u00b6 Kristian Hamre-Os Backend Lead Cecilie Daae Nilsen Backend Developer Jonas Berdal Backend Developer","title":"About our Backend Team"},{"location":"backend/about/#about-our-backend-team","text":"Kristian Hamre-Os Backend Lead Cecilie Daae Nilsen Backend Developer Jonas Berdal Backend Developer","title":"About our Backend Team"},{"location":"cloud/about/","text":"About our Cloud Team \u00b6 Fredrick Myrvoll Cloud Lead Didrik Finn\u00f8y Cloud Engineer","title":"About our Cloud Team"},{"location":"cloud/about/#about-our-cloud-team","text":"Fredrick Myrvoll Cloud Lead Didrik Finn\u00f8y Cloud Engineer","title":"About our Cloud Team"},{"location":"cloud/writing-configuration/config-oriented-code/","text":"Configuration oriented code \u00b6 If we want to provision Virtual Machines in the cloud, we just communicate this desire to our cloud providers. If we want to deploy some app, we just communicate this desire to our clusters. DevOps people are generally expected to declare 'what' they want, while the imperative 'how' aspect often gets abstracted away by other peoples' software. Time forgets \u00b6 https://abstrusegoose.com/432 I think the image above will resonate with most developers, and it's not an experience limited to other peoples' code. Understanding what's actually happening within some repository requires a lot of cognitive calories. Being configuration oriented is all about making declarative code easier to understand. Taking a configuration oriented approach means centralizing the most important declarative information, and presenting it in a way that's easy to read. If we do this well, we are left with something that almost feels like documentation. Functional documentation. Documentation that dictates what happens when the code is executed. Sounds like a lot of work. But then again, writing and maintaining code is a lot of work. The effort you exert toward being configuration oriented should be thought of as an investment. You do some extra work upfront, and if you pull it off, you'll save yourself a lot of trouble in the future. To better understand this, we will categorize the process of writing code into two phases ; the initial phase , and the long-term . The initial phase, and the long-term \u00b6 At no point in time will you understand your own code better than the moment you wrote it. We will refer to this moment, and the moments immediately following, as the initial phase. In this phase, you are bootstrapping your repository, writing code, solving problems, and doing what you do. A common mistake developers make during the initial phase is to overestimate their own memory. If you write code that relies memory to be understood, you will manifest the scenario illustrated above. I would therefore argue that it is wise to focus on the long-term during the initial phase of writing code. In the long-term, there are two reasons why you might revisit the code you wrote in the initial phase; to understand what's happening, or to modify what's happening. Writing code for the long term means that we strive to make things easy to understand, and easy to modify; simply writing code that works is not sufficient. Configuration oriented principles \u00b6 One of the central ideas behind what I refer to as being configuration oriented, is to minimize the number of files developers are likely to interact with in the long-term. Ideally, configuration oriented code should have one configuration file per environment (eg. prod.yaml , dev.yaml , etc.). These files should be structured in a way that maximises how informative they are from the perspective of a developer who has no idea what the code actually does. The way we accomplish this in the Cloud team at Bulder Bank, is to write our configuration as YAML files, and prioritize readability. We can choose any structure we want, the price we pay is that the configuration must be imparatively parsed (or translated if you will) into the input formats expected by whatever tool we are working with. Long story short, being configuration oriented means that we allow extra complexity into our code for the sake of an eye-friendly configuration file. Writing code during the initial phase becomes more difficult, while managing that code in the long term becomes a whole lot easier. Plan for the future, anticipate change \u00b6 During the initial phase, the developer must continually question what modifications people are likely to need in the future. For example, if we're dealing with a Terraform repository for assigning IAM roles to users, people will likely want to add new IAM rules over time. In that case, the Terraform code should be structured in a way where this can be accomplished by simply updating the configuration; it should not be necessary to modify the underlying Terraform code (the for_each loop is your friend). Planning for the future is tricky. A common trap is to overthink it, and spend far too much time implementing configuration-driven features that nobody will ever use. Experience, and a solid understanding of the underlying problem is as crucial as ever when anticipating future demands on some code repository. Minimize the number of files you're likely to care about in the long term \u00b6 Experienced DevOps people will agree that the complexity of Infrastructure as Code projects skyrocket when you introduce the requirement for multiple environments. For example, if you are required to maintain a production environment, a staging environment, and a development environment, the initial phase of writing code becomes a lot more challanging, regardless of your approach. This seems to be a fundamental problem within Infrastructure as Code, and it seems like every DevOps team has their own unique approach to solving the problem. From a configuration oriented point of view, this problem should be solved by isolating differences into environment's respective configuration files. Each environment gets its own configuration, while the code that consumes this configuration should be as environmentally agnostic as possible. Anyone who has tried to implement this kind of pattern will appreciate that it's a difficult thing to accomplish. Part of the reason why this is so difficult, is that there are countless ways to approach the problem, and not a whole lot of non-trivial online examples to learn from. Nevertheless, it is a worthwhile problem to solve as it simplifies long-term code interaction, and makes pull requests a lot more concise. Make configuration files as informative as possible \u00b6 Consider the following examples for Terraform input values. Which do you find more intuitive, and which do you think would fare better if we added hundreds of additional lines in the same format: Example 1 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # ./config.yaml iam : - email : friend@org.com membership : - role : roles/compute.viewer project : project-b - email : buddy@org.com membership : - role : roles/container.viewer project : project-a - email : guy@org.com membership : - role : roles/dns.admin project : project-a - role : roles/storage.admin project : project-b Example 2 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # ./iam.tfvars friend_email = \"friend@org.com\" friend_role_1 = \"roles/compute.viewer\" friend_project_1 = \"project-b\" buddy_email = \"buddy@org.com\" buddy_role_1 = \"roles/container.viewer\" buddy_project_1 = \"project-a\" guy_email = \"guy@org.com\" guy_role_1 = \"roles/dns.admin\" guy_project_1 = \"project-a\" guy_role_2 = \"roles/storage.admin\" guy_project_2 = \"project-b\" Some subjective observations on the above: Example 1 is more readable (assuming the reader has seen YAML before). Example 1 is more difficult to transform into a format that Terraform understands. Example 2 makes the initial phase a lot less complicated. In my opinion, Example 1 prioritizes the long-term in a configuration oriented fashion, while Example 2 prioritizes simplicity in the initial phase. Example 1 is a configuration oriented approach, Example 2 is not. If you feel that Example 1 is no more readable than Example 2, my bet is that you would feel differently if we threw a bunch of other resources types into the mix. You may also be wondering why I use YAML instead of HCL in Example 1. If either of these apply to you, please refer to the subsequent article in this series, Configuration oriented Terraform code . Parse the configuration imperatively when needed \u00b6 Configuration oriented approaches usually require custom imperative logic. This is to be expected; it's the main reason why the initial phase of development becomes more challenging when adopting a configuration oriented approach. To illustrate, lets build on the Terraform examples: Assume you have some module that creates IAM rules based on input values from your configuration file. We'll start with Example 2, as this will be more familiar to most Terraform users. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # Example 2 approach # ./iam.tf variable \"friend_email\" {} variable \"friend_project_1\" {} variable \"friend_role_1\" {} variable \"friend_project_2\" {} variable \"friend_role_2\" {} # etc... module \"iam_friend_1\" { source = \"/path/to/module/\" email = var.friend_email project = var.friend_project_1 role = var.friend_role_1 } module \"iam_friend_2\" { source = \"/path/to/module/\" email = var.buddy_email project = var.buddy_project_1 role = var.buddy_role_1 } # etc... This is not a good approach, yet this is probably how most beginners write their first lines of Terraform code. It is the simplest way to get the job done, and there are plenty of scenarios where it's fine to keep things simple. The problem with this approach it lacks readability, and it doesn't scale well. You would have to modify a lot of code, across multiple files, to make simple adjustments (eg. removing an existing IAM role), and understanding what the code does becomes more tedious than it needs to be. For a configuration oriented approach using the input values from Example 1, we need to put some imperative logic inside a locals block to translate our YAML into something Terraform understands. The code might look a bit daunting, but you will rarely need to concern yourself with this imperative logic in the long term. Once you've figured out how to wrangle your configuration into a suitable format, you will never need to revisit the locals block unless you decide to change the structure of your config.yaml file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # Example 1 approach # ./iam.tf locals { # Make `config.yaml` available to Terraform config = yamldecode ( file ( \"./config.yaml\" )) # Convert `local.config.iam` into a `for_each` map: # { # <project>-<role>-<email> = { # email = <email> # project = <project> # role = <role> # } # } iam = { for rule in flatten ([ for person in local.config.iam : [ for roles in person.membership : { email = person.email role = roles.role project = roles.project } ] ]) : join ( \"-\" , [ rule.project, rule.role, rule.email ]) = > rule } } module \"iam\" { source = \"/path/to/module/\" for_each = local.iam email = each.value.email project = each.value.project role = each.value.role } Loops in Terraform v1.0 leave a lot to desired, but but the ability to manipulate the structure of input values is invaluable. Notice the trade-off eluded to earlier, between configuration readability and the complexity of the for_each loop. Concluding remarks \u00b6 Like most things in DevOps, there is no single best solution for organizing declarative code. Putting emphasis on configuration is just another style; I hope that some of you will find it helpful.","title":"Principles"},{"location":"cloud/writing-configuration/config-oriented-code/#configuration-oriented-code","text":"If we want to provision Virtual Machines in the cloud, we just communicate this desire to our cloud providers. If we want to deploy some app, we just communicate this desire to our clusters. DevOps people are generally expected to declare 'what' they want, while the imperative 'how' aspect often gets abstracted away by other peoples' software.","title":"Configuration oriented code"},{"location":"cloud/writing-configuration/config-oriented-code/#time-forgets","text":"https://abstrusegoose.com/432 I think the image above will resonate with most developers, and it's not an experience limited to other peoples' code. Understanding what's actually happening within some repository requires a lot of cognitive calories. Being configuration oriented is all about making declarative code easier to understand. Taking a configuration oriented approach means centralizing the most important declarative information, and presenting it in a way that's easy to read. If we do this well, we are left with something that almost feels like documentation. Functional documentation. Documentation that dictates what happens when the code is executed. Sounds like a lot of work. But then again, writing and maintaining code is a lot of work. The effort you exert toward being configuration oriented should be thought of as an investment. You do some extra work upfront, and if you pull it off, you'll save yourself a lot of trouble in the future. To better understand this, we will categorize the process of writing code into two phases ; the initial phase , and the long-term .","title":"Time forgets"},{"location":"cloud/writing-configuration/config-oriented-code/#the-initial-phase-and-the-long-term","text":"At no point in time will you understand your own code better than the moment you wrote it. We will refer to this moment, and the moments immediately following, as the initial phase. In this phase, you are bootstrapping your repository, writing code, solving problems, and doing what you do. A common mistake developers make during the initial phase is to overestimate their own memory. If you write code that relies memory to be understood, you will manifest the scenario illustrated above. I would therefore argue that it is wise to focus on the long-term during the initial phase of writing code. In the long-term, there are two reasons why you might revisit the code you wrote in the initial phase; to understand what's happening, or to modify what's happening. Writing code for the long term means that we strive to make things easy to understand, and easy to modify; simply writing code that works is not sufficient.","title":"The initial phase, and the long-term"},{"location":"cloud/writing-configuration/config-oriented-code/#configuration-oriented-principles","text":"One of the central ideas behind what I refer to as being configuration oriented, is to minimize the number of files developers are likely to interact with in the long-term. Ideally, configuration oriented code should have one configuration file per environment (eg. prod.yaml , dev.yaml , etc.). These files should be structured in a way that maximises how informative they are from the perspective of a developer who has no idea what the code actually does. The way we accomplish this in the Cloud team at Bulder Bank, is to write our configuration as YAML files, and prioritize readability. We can choose any structure we want, the price we pay is that the configuration must be imparatively parsed (or translated if you will) into the input formats expected by whatever tool we are working with. Long story short, being configuration oriented means that we allow extra complexity into our code for the sake of an eye-friendly configuration file. Writing code during the initial phase becomes more difficult, while managing that code in the long term becomes a whole lot easier.","title":"Configuration oriented principles"},{"location":"cloud/writing-configuration/config-oriented-code/#plan-for-the-future-anticipate-change","text":"During the initial phase, the developer must continually question what modifications people are likely to need in the future. For example, if we're dealing with a Terraform repository for assigning IAM roles to users, people will likely want to add new IAM rules over time. In that case, the Terraform code should be structured in a way where this can be accomplished by simply updating the configuration; it should not be necessary to modify the underlying Terraform code (the for_each loop is your friend). Planning for the future is tricky. A common trap is to overthink it, and spend far too much time implementing configuration-driven features that nobody will ever use. Experience, and a solid understanding of the underlying problem is as crucial as ever when anticipating future demands on some code repository.","title":"Plan for the future, anticipate change"},{"location":"cloud/writing-configuration/config-oriented-code/#minimize-the-number-of-files-youre-likely-to-care-about-in-the-long-term","text":"Experienced DevOps people will agree that the complexity of Infrastructure as Code projects skyrocket when you introduce the requirement for multiple environments. For example, if you are required to maintain a production environment, a staging environment, and a development environment, the initial phase of writing code becomes a lot more challanging, regardless of your approach. This seems to be a fundamental problem within Infrastructure as Code, and it seems like every DevOps team has their own unique approach to solving the problem. From a configuration oriented point of view, this problem should be solved by isolating differences into environment's respective configuration files. Each environment gets its own configuration, while the code that consumes this configuration should be as environmentally agnostic as possible. Anyone who has tried to implement this kind of pattern will appreciate that it's a difficult thing to accomplish. Part of the reason why this is so difficult, is that there are countless ways to approach the problem, and not a whole lot of non-trivial online examples to learn from. Nevertheless, it is a worthwhile problem to solve as it simplifies long-term code interaction, and makes pull requests a lot more concise.","title":"Minimize the number of files you're likely to care about in the long term"},{"location":"cloud/writing-configuration/config-oriented-code/#make-configuration-files-as-informative-as-possible","text":"Consider the following examples for Terraform input values. Which do you find more intuitive, and which do you think would fare better if we added hundreds of additional lines in the same format:","title":"Make configuration files as informative as possible"},{"location":"cloud/writing-configuration/config-oriented-code/#parse-the-configuration-imperatively-when-needed","text":"Configuration oriented approaches usually require custom imperative logic. This is to be expected; it's the main reason why the initial phase of development becomes more challenging when adopting a configuration oriented approach. To illustrate, lets build on the Terraform examples: Assume you have some module that creates IAM rules based on input values from your configuration file. We'll start with Example 2, as this will be more familiar to most Terraform users. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # Example 2 approach # ./iam.tf variable \"friend_email\" {} variable \"friend_project_1\" {} variable \"friend_role_1\" {} variable \"friend_project_2\" {} variable \"friend_role_2\" {} # etc... module \"iam_friend_1\" { source = \"/path/to/module/\" email = var.friend_email project = var.friend_project_1 role = var.friend_role_1 } module \"iam_friend_2\" { source = \"/path/to/module/\" email = var.buddy_email project = var.buddy_project_1 role = var.buddy_role_1 } # etc... This is not a good approach, yet this is probably how most beginners write their first lines of Terraform code. It is the simplest way to get the job done, and there are plenty of scenarios where it's fine to keep things simple. The problem with this approach it lacks readability, and it doesn't scale well. You would have to modify a lot of code, across multiple files, to make simple adjustments (eg. removing an existing IAM role), and understanding what the code does becomes more tedious than it needs to be. For a configuration oriented approach using the input values from Example 1, we need to put some imperative logic inside a locals block to translate our YAML into something Terraform understands. The code might look a bit daunting, but you will rarely need to concern yourself with this imperative logic in the long term. Once you've figured out how to wrangle your configuration into a suitable format, you will never need to revisit the locals block unless you decide to change the structure of your config.yaml file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # Example 1 approach # ./iam.tf locals { # Make `config.yaml` available to Terraform config = yamldecode ( file ( \"./config.yaml\" )) # Convert `local.config.iam` into a `for_each` map: # { # <project>-<role>-<email> = { # email = <email> # project = <project> # role = <role> # } # } iam = { for rule in flatten ([ for person in local.config.iam : [ for roles in person.membership : { email = person.email role = roles.role project = roles.project } ] ]) : join ( \"-\" , [ rule.project, rule.role, rule.email ]) = > rule } } module \"iam\" { source = \"/path/to/module/\" for_each = local.iam email = each.value.email project = each.value.project role = each.value.role } Loops in Terraform v1.0 leave a lot to desired, but but the ability to manipulate the structure of input values is invaluable. Notice the trade-off eluded to earlier, between configuration readability and the complexity of the for_each loop.","title":"Parse the configuration imperatively when needed"},{"location":"cloud/writing-configuration/config-oriented-code/#concluding-remarks","text":"Like most things in DevOps, there is no single best solution for organizing declarative code. Putting emphasis on configuration is just another style; I hope that some of you will find it helpful.","title":"Concluding remarks"},{"location":"cloud/writing-configuration/intro/","text":"Writing good configuration \u00b6 As a Cloud Engineer at Bulder Bank, I spend a great deal of time expressing my desires through declarative code. The motivation behind this series of articles is to share some of the things I've learnt about being declarative. In the first article, I describe what I mean by being configuration oriented , and why I think its important. In the subsequent articles, I give practical examples of configuration oriented approaches to working with some of my favorite tools. Authors \u00b6 Didrik Finn\u00f8y - Cloud Engineer","title":"Intro"},{"location":"cloud/writing-configuration/intro/#writing-good-configuration","text":"As a Cloud Engineer at Bulder Bank, I spend a great deal of time expressing my desires through declarative code. The motivation behind this series of articles is to share some of the things I've learnt about being declarative. In the first article, I describe what I mean by being configuration oriented , and why I think its important. In the subsequent articles, I give practical examples of configuration oriented approaches to working with some of my favorite tools.","title":"Writing good configuration"},{"location":"cloud/writing-configuration/terraform/","text":"Configuration oriented Terraform code \u00b6 This article demonstrates an opinionated pattern for organizing Terraform code. The pattern follows the principles listed in preceding article of this series. Before reading this article, it may be useful to familiarize yourself with how the Terraform documentation suggests we organize our code: https://learn.hashicorp.com/tutorials/terraform/organize-configuration https://www.hashicorp.com/blog/structuring-hashicorp-terraform-configuration-for-production Directory structure \u00b6 If we want to create a Terraform project with some home-made modules, across two environments ( dev and prod ), the directory layout would look something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u2514\u2500\u2500 my-project \u251c\u2500\u2500 live \u2502 \u251c\u2500\u2500 dev \u2502 \u2502 \u251c\u2500\u2500 modules.tf \u2502 \u2502 \u251c\u2500\u2500 providers.tf \u2502 \u2502 \u2514\u2500\u2500 terraform.tf \u2502 \u2514\u2500\u2500 prod \u2502 \u251c\u2500\u2500 modules.tf \u2502 \u251c\u2500\u2500 providers.tf \u2502 \u2514\u2500\u2500 terraform.tf \u2514\u2500\u2500 modules \u251c\u2500\u2500 module-a \u2502 \u2514\u2500\u2500 main.tf \u2514\u2500\u2500 module-b \u2514\u2500\u2500 main.tf Each modules.tf file would look something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # ./live/*/modules.tf module \"a\" { source = \"../../modules/module-a\" var1 = <some input value> var2 = <some input value> var3 = <some input value> } module \"b\" { source = \"../../modules/module-b\" var1 = <some input value> var2 = <some input value> var3 = <some input value> } Passing input values \u00b6 At this point, we need a strategy for forwarding input values, hereby referred to as configuration , into these module blocks. Option 1: Add configuration directly to modules.tf \u00b6 The simplest approach would be to replace <some input value> , and just hardcode the desired configuration straight into the modules.tf files. This has several drawbacks, some notable examples being: You can't reuse a single input value across multiple modules. If there are a lot of modules, you'll want to spread them across multiple *.tf files; your configuration ends up scattered. You can't copy + paste modules.tf between live/dev and live/prod , so implementing change in both environments becomes a bit fiddly. Option 2: Terraform module variables \u00b6 The textbook approach would be to use variable blocks. In my opinion, this should only be necessary in the child modules ( ./modules/*/variables.tf ), not in the root modules ( ./live/*/variables.tf ). The reason I don't like this approach is that you have to declare every input value in the root module: 1 2 3 4 5 6 7 # ./modules/module-a/variables.tf variable \"var1\" { type = string description = \"Input for something something cloud..\" default = \"whatever\" } 1 2 3 4 5 6 7 8 # ./live/*/modules.tf module \"a\" { source = \"../../modules/module-a\" # Without this line, the active value will be \"whatever\" var1 = var.var1 } 1 2 3 4 5 6 7 # ./live/*/variables.tf variable \"var1\" { type = string description = \"Used with module.a, but not necessarily module.b\" default = \"derp\" } 1 2 3 4 #./live/*/config.auto.tfvars # Without this line, the active value will be either \"derp\" or \"whatever\" var1 = \"cauliflower\" The example above involves seven files across dev and prod . Each of the files displayed above represent a place where the active value for module.a might be defined. When somebody is trying to figure out how some resource in prod is configured, that person might have to traverse four files to find the active value. This can be alleviated with good and consistent Terraform coding style, but I feel that there is too much potential for confusion. Option 3: Use locals \u00b6 Terraform comes with local values , and a nice set of functions for decoding common file structures, like YAML and JSON. In other words, it's possible to do this: 1 2 3 4 5 6 7 8 9 10 11 # ./live/*/config.yaml module-a : var1 : \"x\" var2 : \"y\" var3 : \"z\" module-b : var1 : \"a\" var2 : \"b\" var3 : \"c\" 1 2 3 4 5 # ./live/*/locals.tf locals { config = yamldecode ( file ( \"./config.yaml\" )) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # ./live/*/modules.tf module \"a\" { source = \"../../modules/module-a\" var1 = local.config.module-a.var1 var2 = local.config.module-a.var2 var3 = local.config.module-a.var2 } module \"b\" { source = \"../../modules/module-b\" var1 = local.config.module-b.var1 var2 = local.config.module-b.var2 var3 = local.config.module-b.var3 } The most significant difference between Options 2 and 3, is that there is no need for the ./live/*/variables.tf files. They are replaced with ./live/*/locals.tf , and unlike the variables.tf files, these do not need to be modified when you define new values in config.yaml . This is an enormous advantage. Picture what the ./live/*/variables.tf files from Option 2 would look like if we added all six input varibles for module.a and module.b ; that's a lot of code. With the Option 3 pattern, we no longer need to declare root level variables, anything you declare in config.yaml will automatically be available under the local.config map. At the time of writing, my preferred approach is to combine Option 1 and Option 3. If a value will vary between environments, or if it is important with respect to understanding what the code does, it ends up in config.yaml . Values that will not vary between environments, and that are unlikely to change over time, get hardcoded straight into the module blocks. It is important to note that Option 3 should only be employed in the root modules ( ./live/* ), not in the child modules ( ./modules/* ). YAML vs. HCL \u00b6 Option 3 can easily be accomplished with the HCL file format instead of YAML. We just prefer YAML because it is easier to read (and write). One of the core ideas behind this pattern is that the configuration should be the most informative file within an environment directory. Using YAML makes this file easier to interpret, and the project becomes more accessible to developers who are not familiar with HCL. Practical example \u00b6 In this section we will walk through the process of writing a configuration oriented Terraform project covering multiple environments. The task \u00b6 Create a Terraform structure for Google Cloud Platform that provisions service accounts, and assigns them IAM roles. There should be two environments dev and prod . Assume that the Google Cloud Projects for these environments, dev-project and prod-project already exist. It should be possible to assign IAM roles at the project level, and for storage buckets. Furthermore, it should be possible to assign IAM roles for any GCP project, and any storage bucket. The service accounts will live in dev-project and prod-project , but should be granted some IAM roles in another pre-existing project; shared-project . The approach \u00b6 I always start with the directory layout and the config.yaml files. I focus on dev , and write my code in a way where most of the files can be copy + pasted into prod . We will use the same directory layout illustrated earlier. When writing your config.yaml file; ask yourself what the most intuitive structure would look like. For this particular problem, I would want config.yaml to look something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # ./live/dev/config.yaml gcpProvider : project : dev-project region : europe-west1 # Create service accounts in `dev-project`, and assign IAM roles serviceAccounts : - name : sa-number-one iam : # Assign `sa-number-one` project-level IAM roles in `dev-project` - type : project name : dev-project roles : - roles/storage.admin - roles/secretmanager.admin - name : sa-number-two iam : # Assign `sa-number-two` project-level IAM roles in `shared-project` - type : project name : shared-project roles : - roles/storage.objectViewer # Assign `sa-number-two` bucket-level IAM roles to a Google Container Registry in `shared-project` - type : bucket name : eu.artifacts.shared-project.appspot.com roles : - roles/storage.admin This YAML layout gives me a foundation to build on. The goal is to end up with a strucure where service accounts and IAM roles can be created, destroyed or modified through the config.yaml file. The next step would be to write the root and child modules. The child modules will just contain normal Terraform code, while the root module will have to contain some imperative logic that translates my YAML into the input values expected by the child modules. Please refer to this repository for a complete example based on the YAML configuration depicted above. Some notes on the example: Every file except for config.yaml is identical between dev and prod , so it's easy to copy + paste. Usually, terraform.tf will also differ because the environments have different remote state storage locations. All resource blocks are contained within modules, even though the modules are very simple. We do this because it is arguably cleaner than putting resource blocks directly into the ./live/* directories (try running terraform state list ). The for loops are difficult to understand, but one never has to modify them unless there is a need to modify the structure of config.yaml ; developers will seldom be interested in these loops in the long-term.","title":"Terraform example"},{"location":"cloud/writing-configuration/terraform/#configuration-oriented-terraform-code","text":"This article demonstrates an opinionated pattern for organizing Terraform code. The pattern follows the principles listed in preceding article of this series. Before reading this article, it may be useful to familiarize yourself with how the Terraform documentation suggests we organize our code: https://learn.hashicorp.com/tutorials/terraform/organize-configuration https://www.hashicorp.com/blog/structuring-hashicorp-terraform-configuration-for-production","title":"Configuration oriented Terraform code"},{"location":"cloud/writing-configuration/terraform/#directory-structure","text":"If we want to create a Terraform project with some home-made modules, across two environments ( dev and prod ), the directory layout would look something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u2514\u2500\u2500 my-project \u251c\u2500\u2500 live \u2502 \u251c\u2500\u2500 dev \u2502 \u2502 \u251c\u2500\u2500 modules.tf \u2502 \u2502 \u251c\u2500\u2500 providers.tf \u2502 \u2502 \u2514\u2500\u2500 terraform.tf \u2502 \u2514\u2500\u2500 prod \u2502 \u251c\u2500\u2500 modules.tf \u2502 \u251c\u2500\u2500 providers.tf \u2502 \u2514\u2500\u2500 terraform.tf \u2514\u2500\u2500 modules \u251c\u2500\u2500 module-a \u2502 \u2514\u2500\u2500 main.tf \u2514\u2500\u2500 module-b \u2514\u2500\u2500 main.tf Each modules.tf file would look something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # ./live/*/modules.tf module \"a\" { source = \"../../modules/module-a\" var1 = <some input value> var2 = <some input value> var3 = <some input value> } module \"b\" { source = \"../../modules/module-b\" var1 = <some input value> var2 = <some input value> var3 = <some input value> }","title":"Directory structure"},{"location":"cloud/writing-configuration/terraform/#passing-input-values","text":"At this point, we need a strategy for forwarding input values, hereby referred to as configuration , into these module blocks.","title":"Passing input values"},{"location":"cloud/writing-configuration/terraform/#yaml-vs-hcl","text":"Option 3 can easily be accomplished with the HCL file format instead of YAML. We just prefer YAML because it is easier to read (and write). One of the core ideas behind this pattern is that the configuration should be the most informative file within an environment directory. Using YAML makes this file easier to interpret, and the project becomes more accessible to developers who are not familiar with HCL.","title":"YAML vs. HCL"},{"location":"cloud/writing-configuration/terraform/#practical-example","text":"In this section we will walk through the process of writing a configuration oriented Terraform project covering multiple environments.","title":"Practical example"},{"location":"ios/about/","text":"About our iOS Team \u00b6 Jonathan Hobson iOS Lead Danni Stjerneg\u00e5rd iOS Developer","title":"About our iOS Team"},{"location":"ios/about/#about-our-ios-team","text":"Jonathan Hobson iOS Lead Danni Stjerneg\u00e5rd iOS Developer","title":"About our iOS Team"},{"location":"loan/about/","text":"About our Loan Team \u00b6 Johnny \u00d8vreberg Frontend Lead Roar Bergheim Backend Developer Peer Andreas Stange Backend Developer","title":"About our Loan Team"},{"location":"loan/about/#about-our-loan-team","text":"Johnny \u00d8vreberg Frontend Lead Roar Bergheim Backend Developer Peer Andreas Stange Backend Developer","title":"About our Loan Team"},{"location":"ux/about/","text":"About our UX Team \u00b6 Nicolai M\u00f8ller UX Lead","title":"About our UX Team"},{"location":"ux/about/#about-our-ux-team","text":"Nicolai M\u00f8ller UX Lead","title":"About our UX Team"}]}